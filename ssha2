#!/bin/env ruby

require 'shellwords'
require 'fileutils'
require 'open3'
require  'time'
require 'pty'
require 'io/console'
#require 'Yk/debug2'
require 'digest'

require 'open3'
require 'io/console'

def running_in_wsl?
    File.read("/proc/version").include?("icrosoft") rescue false
end

KEY_CHECK_IN_ADVANCE = ENV["KEY_CHECK_IN_ADVANCE"] == "1"

IN_WSL = running_in_wsl?

SYS_BOOT_TIME = Time.at(`awk '/btime/ {print $2}' /proc/stat`.strip.to_i).to_s.gsub(" ", ".").gsub(":", "-")
PROC_START_CLOCK = IO.read("/proc/#{$$}/stat").split[21].to_i
FPID = "#{PROC_START_CLOCK}.#{Process.pid}"

BY_WIN = IN_WSL
BY_SSH_BAT = ENV["VSCODE_BAT"] == "1"
BY_VSCODE = ENV["VSCODE_NONCE"] && !ENV["VSCODE_NONCE"].empty?
SSH_ORG_PTY = BY_SSH_BAT ? ["/mnt/c/Program Files/Git/usr/bin/winpty.exe", "-Xallow-non-tty", "ssh.exe"] : ["ssh"]
SSH_ORG = BY_SSH_BAT ? "ssh.exe" : "ssh"


SSH_ADD_PTY = BY_SSH_BAT ? ["/mnt/c/Program Files/Git/usr/bin/winpty.exe",  "-Xallow-non-tty", "ssh-add.exe"] : ["ssh-add"]
SSH_ADD = BY_SSH_BAT ? "ssh-add.exe" : "ssh-add"

SSHA_HOME = "#{ENV['HOME']}/.ssha"

#ENV['PATH'] =~ /mnt/c/Users/.*?\/Appdata/ ? VSCODE_BAT = 1 : VSCODE_BAT = 0

WHOMEW = IN_WSL ? `cmd.exe /c 'echo %USERPROFILE%' 2>/dev/null < /dev/null`.chomp : nil
WHOMEL = IN_WSL ? `wslpath '#{WHOMEW}'`.chomp : nil

DEBWF = "#{ENV['HOME']}/.ssha/debug_writer"

def openWriter
    fName = DEBWF
    if !File.exist? fName
        system "mkfifo #{fName}"
    end
    Dir.glob "/proc/*/cmdline" do |cmdline|
        begin
            cmd = IO.read(cmdline).split("\0")
            if cmd == %W{tail -F /home/yougain/.ssha/debug_writer}
                return
            end
        rescue
        end
    end
    system "cd #{WHOMEL}; cmd.exe /c wt wsl -e tail -F #{fName} < /dev/null"
end


openWriter if ENV["DEBUG"]


def aout buff
    IO.write DEBWF, buff.inspect.gsub("\\n", "\\n\n") if ENV["DEBUG"]
end

WSSHA_HOMEL = IN_WSL ? "#{WHOMEL}/.ssha" : nil
LOGD = "#{SSHA_HOME}/logs"
FileUtils.mkdir_p LOGD
TMP_ROOTS = "#{SSHA_HOME}/tmp/boot"
WTMP_ROOTSL = "#{WSSHA_HOMEL}/tmp/boot"
TMP_ROOT = "#{TMP_ROOTS}/#{SYS_BOOT_TIME}"
WTMP_ROOTL = "#{WTMP_ROOTSL}/#{SYS_BOOT_TIME}"
FileUtils.mkdir_p TMP_ROOT
FileUtils.mkdir_p WTMP_ROOTL

FileUtils.chmod 0700, SSHA_HOME



[TMP_ROOTS, WTMP_ROOTSL].each do |root|
    Dir.glob "#{root}/*" do |d|
        if d != root + "/#{SYS_BOOT_TIME}"
            FileUtils.rm_rf d rescue nil
        end
    end
end

TMPD = "#{TMP_ROOT}/ssha-#{FPID}" # TMPD = TMP_ROOT /ssha-$FPID
WTMPDL = "#{WTMP_ROOTL}/ssha-#{FPID}"

FileUtils.mkdir_p TMPD
FileUtils.mkdir_p WTMPDL
WTMPDW = IN_WSL ? (`wslpath -w '#{WTMPDL}' 2>/dev/null`.chomp rescue nil) : nil


SESSION_ID = Process.getsid(0) # 現在のセッションIDを取得
SESSION_START_CLOCK = IO.read("/proc/#{SESSION_ID}/stat").split[21].to_i
FSID = "#{SESSION_START_CLOCK}.#{SESSION_ID}"


VSC_WSL_PORT=41235
VSCODE = `find ~/.vscode-server -name code 2> /dev/null | head -1`.strip


Prog = File.basename($0)
ProgDir= File.dirname(`readlink -f #{$0}`)
require "#{ProgDir}/ask.rb"
require "#{ProgDir}/agent.rb"
require "#{ProgDir}/key.rb"



class Err < StandardError; end



VSC_EDIT_DIR = "#{SSHA_HOME}/vscode_edit" # VSC_EDIT_DIR = SSHA_HOME /vscode_edit
VSC_EDIT_DAEMON_DIR = "#{SSHA_HOME}/vscode_edit_daemons/#{SYS_BOOT_TIME}" # VSC_EDIT_DAEMON_DIR = SSHA_HOME /vscode_edit_daemons / SYS_BOOT_TIME


if false
if BY_VSCODE # vscode's direct child process for remote ssh connection, maybe in WSL
    fork do
        # STDERR.reopen VSC_EDIT_DIR /vscode_edit_daemon.log, "a"
        STDERR.reopen "#{VSC_EDIT_DIR}/vscode_edit_daemon.log", "a"
        FileUtils.mkdir_p VSC_EDIT_DAEMON_DIR rescue nil
        # start = $ cat /proc/$$/stat | awk '{print $22}'
        start = `cat /proc/#{Process.pid}/stat | awk '{print $22}'`.strip
        # vsc_edit_daemon_pipe = VSC_EDIT_DAEMON_DIR / start . Process.pid
        # example # fd = ~/.ssha{!}/data'open-rw
        vsc_edit_daemon_pipe = "#{VSC_EDIT_DAEMON_DIR}/#{start}.#{Process.pid}"
        to_daemon = vsc_edit_daemon_pipe + ".to"
        from_daemon = vsc_edit_daemon_pipe + ".from"
        File.mkfifo to_daemon
        File.mkfifo from_daemon
        END{
          File.delete to_daemon rescue nil
          File.delete from_daemon rescue nil
        }
        Thread.new do
          loop do
            paths = []
            File.open to_daemon do |fr|
              fr.flock File::LOCK_EX
              fr.each_line do |ln|
                paths << ln.chomp
              end
            end
            ret = (Process.ppid != 1 and system VSCODE, *paths) ? "OK" : "ERROR"
              File.open from_daemon do |fw|
                fw.flock File::LOCK_EX
                fw.write ret + "\n"
              end
            if Process.pid == 1
              exit 1
            end
          end
        end
        #      ents.each do |ent|
        #          File.delete ent rescue nil
        #      end
        #    else
        #      
        #    end
        #end
        loop do
            sleep 300
            if Process.ppid != 1
                begin
                    Process.getpgid(Process.ppid)
                rescue Errno::ESRCH
                    exit 0
                end
            else
                exit 0
            end
        end
    end
end
end


def sshCommand sshc, cmd = []
    ret = nil
    PTY.spawn "SSH_ASKPASS=\"\" " + [*%W{#{SSH_ORG_PTY.join(' ')} -t}, *sshc, *cmd].shelljoin do |r, w, pid|
        tr, tw = IO.pipe
        t = nil
        mt = Thread.new do
            t = Process.detach pid
            t.join
            tw.write "exit\n"
            tw.flush
        end
        Thread.pass
        line = ""
        loop do
            if pid_exited?(pid)
                break
            end
            ra, = select [r, tr]
            if ra == [tr]
                break
            end
            d = r.readpartial(1024) rescue nil
            if d
                line << d
            end
            lines = line.lines
            i = 0
            lines.each do |l|
                yield l, w
                if !d
                    break
                end
                i += 1
            end
            line = ""
        end
        mt.join
        ret = t.value.to_i == 0
    end
    ret
end
           

def pid_exited?(pid)
    begin
      # シグナル0を送信してプロセスの存在を確認
      Process.kill(0, pid)
      false # プロセスが存在する場合
    rescue Errno::ESRCH
      true  # プロセスが存在しない場合（終了している）
    rescue Errno::EPERM
      false # プロセスが存在するがアクセス権がない場合
    end
end

def _clobber dir, num, max
    if File.exist? "#{dir}/#{num}"
        if num < max
            _clobber dir, num + 1, max
            FileUtils.mv "#{dir}/#{num}", "#{dir}/#{num + 1}"
        else
            FileUtils.rm "#{dir}/#{num + 1}"
        end
    end
end

def clobber dir, max
    _clobber dir, 1, max
end

def registerConfig host, user, port, idFile, confPos
    if confPos.empty?
        if File.exist?("#{ENV['HOME']}/.ssh/config")
            FileUtils.cp "#{ENV['HOME']}/.ssh/config", "#{ENV['HOME']}/.ssh/config.bak"
        else
            FileUtils.mkdir_p "#{ENV['HOME']}/.ssh"
            FileUtils.chmod 0700, "#{ENV['HOME']}/.ssh"
            FileUtils.touch "#{ENV['HOME']}/.ssh/config"
        end
        File.open("#{ENV['HOME']}/.ssh/config", "a") do |f|
            f.puts "# Generated by ssha2 at #{Time.now}"
            f.puts "Host #{host}"
            f.puts "    User #{user}"
            f.puts "    Port #{port}"
            f.puts "    IdentityFile #{idFile}" if idFile
            f.puts ""
        end
    else
        file, lno = confPos[0].split ":"
        lno = lno.to_i
        if File.exist? file
            lns = IO.readlines(file)
            s = lno - 1
            prevContent = ["#{File.mtime(file)} #{confPos[0]}\n\n"]
            if lns[s] =~ /\s*Host\s+#{Regexp.escape host}\s*(#|$)/
                prevContent << lns[s]
                last = lns.size
                user_set, port_set, idFile_set = false, false, false
                bind = binding
                mod = false
                found = {}
                same_or_replace = proc do |i, key, value|
                    if lns[i] =~ /^(\s*)#{Regexp.escape key}\s+(\S+)(\s*)(#|$)/i
                        if $2 != value
                            mod = true
                            lns[i] = "#{$1}#{key} #{value}#{$3}# Modified from '#{$2}' by ssha2 at #{Time.now}\n"
                        end
                        found[key] = true
                    end
                end
                set_or_insert = proc do |key, value|
                    if !found[key]
                        lns.insert last, "#{key} #{value} # Inserted by ssha2 at #{Time.now}\n"
                        mod = true
                    end
                end
                nonBlank = nil
                (s + 1).upto (lns.size - 1) do |i|
                    if lns[i] =~ /\s*Host\s+/
                        last = nonBlank + 1 || i
                        break
                    end
                    if !lns[i].strip.empty?
                        nonBlank = i
                    end
                    prevContent << lns[i]
                    same_or_replace.call i, "User", user
                    same_or_replace.call i, "Port" , port
                    same_or_replace.call i, "IdentityFile", idFile if idFile
                end
                set_or_insert.call "User", user
                set_or_insert.call "Port", port
                set_or_insert.call "IdentityFile", idFile if idFile
                if mod
                    FileUtils.mv file, "#{file}.bak"
                    IO.write file, lns.join
                    FileUtils.chmod 0600, file
                    d = "#{SSHA_HOME}/config_history/#{host}"
                    FileUtils.mkdir_p d
                    clobber d, 10
                    IO.write "#{d}/1", prevContent.join
                end
            else
                userPrompt :msg, "ERROR: cannot register config."
                exit 1
            end
        end
    end
end

def finger2file finger
    
end


def doCheck sshc, dest, modIdFiles, fing2File, pw = nil
    mode = []
    loop do
        rn = rand(10**9..10**10-1)
        buff = ""
        line = ""
        finger = nil
        clearKeysInSSHAgent
        null = open('/dev/null','w')
        system *SSH_ORG , *%W{-O exit}, dest, out: null, err: null
        sshCommand ["-v"] + sshc, %W{echo #{rn}} do |l, w|
            case l
            when /^\r*Enter passphrase for key '(.*?)': /
                finger = nil
                idFile = File.expand_path $1
                if idFile == IdFile && !PassPhrase.empty?
                    w.write PassPhrase + "\r\n"
                    w.flush
                    mode << [idFile, PassPhrase]
                elsif modIdFiles.include? idFile
                    passPhrase = userPrompt :passwd, "Enter passphrase for key '#{$1}': "
                    w.write passPhrase 
                    w.flush
                    w.write "\r\n"
                    w.flush
                    mode << [idFile, passPhrase]
                else
                    w.write "\r\n"
                    w.flush
                end
            when /'s password: /
                mode << :password
                if !pw
                    w.write "\r\n"
                    w.flush
                else
                    w.write pw + "\r\n"
                    w.flush
                end
            when /^#{rn}/
                mode << :success
                if mode[-2].is_a?(Array)
                    idFile, passPhrase = mode[-2]
                    PassPhrase.replace passPhrase
                    IdFile.replace idFile
                else
                    idFile = nil
                end
                user, host, port = nil
                confPos = []
                sshCommand ["-G", "-v"] + sshc do |l, w|
                    case l
                    when /^user /
                        user = $'.strip
                    when /^host /
                        host = $'.strip
                    when /^port /
                        port = $'.strip
                    when /^debug1: (.*?) line (\d+): Applying options for #{Regexp.escape dest}\r*$/
                        confPos.push "#{File.expand_path $1}:#{$2}"
                    end
                end
                registerConfig host, user, port, idFile, confPos
            when /^\r*Permission denied, please try again.\r*/
                w.write "\r\n"
                w.flush
            when /^debug1: Server accepts key: (.*)/
                finger = $1.strip.split[2]
            when /^Authenticated to .* using "publickey"\./
                if finger # id without passphrase
                    mode << [fing2File[finger], ""]
                end
                finger = nil
            when /Connection refused/
                mode << :connection_refused
                userPrompt :msg, l.chomp
            when /No route to host/
                mode << :no_route_to_host
                userPrompt :msg, l.chomp
            when /Are you sure you want to continue connecting/
                yn = userPrompt :yn, l.chomp
                w.write yn + "\r\n"
            when /Please type \'yes\'\, \'no\' or the fingerprint:/
                input = userPrompt :input, l.chomp
                w.write input + "\r\n"
            when /Host key verification failed/
                mode << :host_key_verification_failed
                userPrompt :msg, l.chomp
            end
        end
        if !mode.empty? && mode.all?{ _1 == :password } && !pw
            createAndInstallKey sshc, dest
            redo
        end
        break
    end
    mode
end

def strip_control_chars str
    str.gsub(/\e\[[0-9;]*[a-zA-Z]/, '')  # エスケープシーケンス
       .gsub(/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]/, '')  # 制御文字（\n,\r,\t以外）
end


def do_ssh *args

    if KEY_CHECK_IN_ADVANCE
        exec *args
    else
        #ENV.delete 'SSH_ASKPASS'
        wsz = STDIN.winsize
        shellID = "#{FPID}.#{rand(10000000000).to_s}"
        args.pop # remove temporary shell for KEY_CHECK_IN_ADVANCE=1
        args.push "SHELL_ID=#{shellID} WINSZ=#{wsz.join(",")} bash -l"
        case args[0]
        when "ssh"
        when "ssh.exe"
            args.unshift "-Xallow-non-tty"
            args.unshift "/mnt/c/Program Files/Git/usr/bin/winpty.exe"
        end
        pid = nil
        wsz = STDIN.winsize
        slv = nil
        trap :WINCH do
            begin
                new_wsz = STDIN.winsize
                if new_wsz != wsz
                    wsz = new_wsz
                    if pid
                        begin
                            if slv && !slv.closed?
                                slv.winsize = wsz
                                Process.kill :WINCH, pid if pid
                            end
                        rescue Errno::ESRCH
                        end
                    end
                end
            rescue
            end
        end
        PTY.open do |master, slave|
            slv = slave
            master.sync = true
            slave.sync = true
            slave.winsize = wsz
            #ENV['SSH_ASKPASS'] = ""
            pid = fork do
                master.close
                STDERR.reopen slave, "w"
                STDOUT.reopen slave, "w"
                STDIN.reopen slave
                slave.close
                3.upto(1023) do |fd|
                    IO.for_fd(fd).close rescue nil
                end
                exec *args
            end
            begin
                #STDERR.reopen slave, "w"
                slave.close
                begin
                    lBuff = []
                    residue = ""
                    inited = false
                    cmded = false
                    vport = nil
                    cnt = 0
                    selection = [master]
                    loop do
                        rs, = IO.select selection
                        aout rs
                        if rs.include? master
                            begin
                                cdata = master.readpartial(1024)
                            rescue Errno::EIO, EOFError
                                break
                            end
                            aout cdata
                            if !inited
                                begin
                                    printPos = residue.size
                                    data = residue + cdata
                                    case data
                                    when /Allocated port (\d+) for remote forward to 127.0.0.1:\d+/
                                        vport = $1
                                        if $`.size < printPos
                                            data = $'
                                            printPos = 0
                                        else
                                            data = $` + $'
                                        end
                                    when /SHELL_ID=#{shellID.gsub(/\./, "\\.")}/
                                        if $`.size < printPos
                                            data = $'
                                            printPos = 0
                                        else
                                            data = $` + $'
                                        end
                                        # register config
                                    end
                                    dLines = data.lines
                                    if dLines[-1][-1] != "\n"
                                        residue = dLines.pop
                                    end
                                    lBuff += dLines
                                    #p "residue:#{strip_control_chars(residue)}"
                                    if !cmded && strip_control_chars(residue) =~ /\]\$/ # command prompt
                                        master.write <<~END
                                            if true; then
                                                export SYS_START=$(awk '/btime/ {print $2}' /proc/stat)
                                                export SSH_VSCODE_PORT=#{vport}
                                                mkdir -p /tmp/vscode-ssh-ports/$SYS_START
                                                str="`grep SHELL_ID=#{shellID} /proc/*/environ 2>&1| grep binary | awk -F'/' '{print $3}'`"
                                                for s in $str; do
                                                    if [[ $s =~ ^[0-9]+$ ]] && [ -r /proc/$s/stat ]; then
                                                        sppid="$(awk '{print $4}' /proc/$s/stat 2>&1)"
                                                        if [ -n "$sppid" ]; then
                                                            read cl < /proc/$sppid/cmdline
                                                            if [[ $cl == "sshd-session:"* ]]; then
                                                                spid=$s
                                                                st=$(awk '{print $22}' /proc/$sppid/stat)
                                                                echo #{vport} > /tmp/vscode-ssh-ports/$SYS_START/$st.$sppid
                                                            fi
                                                        fi
                                                    fi
                                                done
                                                for d in /tmp/vscode-ssh-ports/*; do
                                                    if [ "$(basename $d)" != "$SYS_START" ]; then
                                                        rm -rf $d
                                                    fi
                                                done
                                                for ent in /tmp/vscode-ssh-ports/$SYS_START/*; do
                                                    tmp=$(basename $ent)
                                                    if ! kill -s 0 ${tmp#*.} 2>&1; then
                                                        rm -f $ent
                                                    fi
                                                done
                                                while IFS= read -r var; do
                                                    if [[ $var == SSH* ]]; then
                                                        export "$var"
                                                    fi
                                                done < <(tr '\\0' '\\n' < /proc/$spid/environ)
                                                sdafsadfsadf
                                                exec `getent passwd "$USER" | cut -d: -f7`
                                            fi
                                        END
                                        
                                        master.flush
                                        residue = ""
                                        cmded = true
                                    end
                                    if data =~ /bash: sdafsadfsadf: command not found/
                                        inited = true
                                        selection << STDIN
                                        STDIN.raw!
                                    end
                                rescue EOFError
                                    break
                                end
                            else
                                STDOUT.write cdata
                                STDOUT.flush
                            end
                        end
                        if rs.include? STDIN
                            begin
                                data = STDIN.readpartial(1024)
                                aout data
                                master.write data
                                master.flush
                            rescue EOFError
                                break
                            end
                        end
                    end
                ensure
                    STDIN.cooked!
                end
            ensure
                Process.waitpid pid
            end
        end
    end
end

if BY_WIN
    if ! File.exist?("/mnt/c/Program Files/Git/usr/bin/winpty.exe")
        userPrompt :msg, "ERROR: '/mnt/c/Program Files/Git/usr/bin/winpty.exe', not found. please install Git for Windows."
        exit 1
    end
end




check = false

def clause
    yield
end

def main
    optArgs = {}
    clause do
        case ARGV[0]
        when "--ssh-agent"
            ARGV.shift
            while !ARGV.empty?
                case ARGV[0]
                when "--"
                    ARGV.shift
                    break
                when /^\-([^\s]*)/
                    $1.each_char do |c|
                        if "aEOPt".include?(c)
                            optArgs[c] = $' != "" ? $' : ARGV.shift
                            break
                        else
                            optArgs[c] = true
                        end
                    end
                    ARGV.shift
                else
                    break
                end
            end
            cmdline = ARGV
            if optArgs["k"] && cmdline.empty?
                destroySSHAgent
                exit 0
            end
            if optArgs.empty? && cmdline.empty?
                displaySSHAgentParams
                exit 0
            end
            STDERR.puts "ERROR: unsupported options/commands.\n       This is a modified ssh-agent. Please use '/usr/bin/ssh-agent ...'."
            exit 1
        when "--ssh-add"
            ARGV.shift
            getKeyListInSSHAgent
            exec "/usr/bin/ssh-add", *ARGV
        when "--ask"
            ARGV.shift
            res = userPrompt :passwd, ARGV[0]
            puts res
            exit 0
        when "--print_tmp_script_file_name"
            print_tmp_script_file_name = true
            ARGV.shift
            redo
        when "--server"
            require "#{ProgDir}/proot_server.rb"
            proot_server            
        when "--check"
            ARGV.shift
            check = true
            redo
        else
            nextIsOptArg = false
            dest = nil
            cmdarr = []
            cmdpos = nil
            terminal = false
            inserter = %W{proot-distro login ubuntu --bind /dev/null:/etc/mtab -- su #{ENV['USER']} -c}
            curOpt = nil
            optArg = Hash.new{|h, k| h[k] = []}
            optLine = []
            optFin = false
            subsys = false

            u = `#{SSH_ORG} 2>&1 < /dev/null` # for Windows ssh.exe initial setup
            aOpts = ""
            if u =~ /\[\-(\w\w+)\]/
                sOpts = $1
            end
            while u =~ /\[\-(\w) /
                aOpts += $1
                u = $'
            end

            ARGV.each_with_index do |arg, i|
                if cmdarr.empty?
                if !optFin
                    if nextIsOptArg
                        nextIsOptArg = false
                        optArg[curOpt].push arg
                        optLine.push "-#{curOpt}", arg
                        next
                    end
                    # 先頭が-の引数はオプション引数とみなす
                    if arg == "--"
                        optFin = true
                        next
                    elsif arg =~ /^\-/
                        curOpt = nil
                        $'.each_char do |c|
                            if curOpt.nil?
                                case c
                                when "s"
                                    subsys = true
                                when "t"
                                    terminal = true
                                when "T"
                                    terminal = false
                                when /^[#{sOpts}]$/
                                        optLine.push "-#{c}"
                                when /^[#{aOpts}]$/
                                    optArg[curOpt = $&].push ""
                                end
                            else
                                optArg[curOpt][-1] += c
                            end
                        end
                        if curOpt
                            if optArg[curOpt][-1] == ""
                                nextIsOptArg = true
                            else
                                optLine.push "-#{curOpt}", optArg[curOpt][-1]
                            end
                        end
                        next
                    end
                end
                if !dest
                    dest = arg
                else
                    cmdpos = i
                    cmdarr << arg        
                end
                else
                    cmdarr << arg
                end
            end

            if !cmdpos
                optLine <<  "-t"
                cmdarr = []
                terminal = true
            end
            sshc = optLine + ["--", dest]

            user = nil
            host = nil
            port = nil
            hostname = nil
            idFileList = []
            
            paramLines = []
            IO.popen "echo 1 |SSH_ASKPASS=\"\" " + [*%W{ssh -G}, *sshc].shelljoin + " 2>&1 </dev/null" do |io|
                io.each_line do |line|
                    case line
                    when /^user /
                        user = $'.strip
                    when /^host /
                        host = $'.strip
                    when /^hostname/
                        hostname = $'.strip
                    when /^port /
                        port = $'.strip
                    when /^identityfile /
                        idFileList.push File.expand_path($'.strip)
                    end
                    paramLines << line
                end
            end
            paramLines.reject!{ _1 =~ /^\w+algorithms / || _1 =~ /^Pseudo\-terminal/ }

            idFileFingList = {} 
            idFileFingToFileName = {}
            idFileList.each do |idf|
                if File.exist? idf
                    fing = getFing(idf)
                    idFileFingList[idf] = fing
                end                
            end
            id_files_content = ""
            fing2File = {}
            idFileFingList.each do |idf, fing|
                id_files_content << "#{fing} #{idf}\n"
                fing2File[fing] ||= idf
            end
            prev_id_files_content = IO.read "#{SSHA_HOME}/id_files" rescue ""
            if check
                testFiles = idFileList
            elsif prev_id_files_content != id_files_content
                #p prev_id_files_content
                #p id_files_content
                prev_a = []
                prev_id_files_content.each_line do |line|
                    if line =~ /\#/
                        line = $`
                    end
                    prev_a << line.strip.split(" ", 2).values_at(1, 0)
                end
                modifiedFiles = []
                (idFileFingList.to_a - prev_a).each do |idf, fing|
                    modifiedFiles.push idf
                end
                testFiles = modifiedFiles
            else
                testFiles = []
            end
            if !testFiles.empty?
                if (resc = doCheck(sshc, dest, testFiles, fing2File)[-1]) == :success
                    IO.write "#{SSHA_HOME}/id_files", id_files_content
                end
            end
            
            if !user
                userPrompt :msg, paramLines.join
                exit 1
            end

            if SSH_ORG == "ssh.exe"

                IO.write "#{WTMPDL}/config", paramLines.join
                loop do
                    badLines = []
                    fcnt = 0
                    IO.popen "cd #{WTMPDL};ssh.exe -G -F config #{dest} 2>&1 </dev/null" do |fr|
                        fr.each_line do |ln|
                            ln.chomp!
                            if ln =~ /: line (\d+): Bad /
                                badLines.push $1.to_i
                            end
                        end
                    end
                    j = 0
                    if badLines.empty?
                        break
                    end
                    File.open "#{WTMPDL}/config", "w" do |fw|
                        paramLines.each_with_index do |ln, i|
                            if i + 1 == badLines[j]
                                # remove bad lines
                                j = j + 1
                                next
                            end
                            if ln !~ /\# replaced by ssha2/ && ln =~ /^(\w+)file /
                                files = $'.split
                                pre = $1 + "file "
                                # copy under windows userprofile and replace file parameter on config file
                                wfiles = []
                                files.each do |fi|
                                    fi = File.expand_path fi
                                    if File.exist? fi
                                        fcnt += 1
                                        FileUtils.cp fi, WTMPDL + "/file." + fcnt.to_s
                                        wfiles.push WTMPDW + "\\file." + fcnt.to_s
                                    end
                                end
                                if !wfiles.empty?
                                    ln = pre + wfiles.join(" ") + " # replaced by ssha2"
                                else
                                    next
                                end
                            end
                            fw.write ln
                        end
                    end
                end
            end

            # setting ENV for ssh-add
            added = getKeyListInSSHAgent

            if KEY_CHECK_IN_ADVANCE
                res = catch :key_available do
                    idFileList.each do |idf|
                        if File.exist? idf
                            if key_has_passphrase? idf
                                finger = getFing idf
                                if !added.include? finger
                                    errExit = proc do
                                        userPrompt :msg, "ERROR: #{idf} not added to ssh-agent\nPlease add it with ssh-add #{idf}"
                                        exit 1
                                    end
                                    if PassPhrase.empty?
                                        phrase = userPrompt :passwd, "Input passphrase for #{idf}: "
                                        if ssh_add idf, phrase
                                            PassPhrase.replace phrase
                                            IdFile.replace idf
                                        else
                                            errExit.call
                                        end
                                    elsif idf == IdFile
                                        ssh_add idf, PassPhrase or errExit.call
                                        IdFile.replace idf
                                    end
                                end
                            end
                            throw :key_available, :key_available
                        end
                    end
                end 
                res == :key_available or (
                    if !check
                        check = true
                        redo
                    end
                    userPrompt :msg, "ERROR: no key available"
                    exit 1
                )
            end

            #if IN_WSL && !`which winInputBox 2> /dev/null`.strip.empty?
            #    ENV['SSH_ASKPASS'] = `which winInputBox 2> /dev/null`.strip
            #end

            logit = proc do |msg|
                File.open "#{SSHA_HOME}/cmd_log", "a" do |f|
                    f.write "ssh[#{$$}] #{Time.now.strftime("%Y-%m-%d %H:%M:%S.%L")} #{msg}\n"
                end
            end
            if ENV['SSHA_CMD_LOG']
                logit.call "started: ssh #{ARGV.join(" ")}"
            end
            info_d = "#{SSHA_HOME}/limited_controlled_hosts/#{dest}:#{port}"
            limit = IO.read("#{info_d}/limit").to_i rescue nil
            prev = IO.read("#{info_d}/.prev_trial").to_i rescue 0
            r, w = nil
            if limit
                btime = `grep btime /proc/stat`.split[1]
                proc_unique = "#{btime}/#{File.read("/proc/#{$$}/stat").split[21].to_i}-#{$$}"
                info_d_each = "#{info_d}/#{proc_unique}"
                FileUtils.mkdir_p info_d_each
                if (Time.now.to_i - prev) > limit
                    closeControlCMD = "#{SSH_ORG} -O exit #{port && "-p #{port}"} #{dest}"
                    system "#{closeControlCMD} > /dev/null 2>/dev/null"
                    logit.call closeControlCMD
                end
                IO.write "#{info_d}/.prev_trial", Time.now.to_i

                if ENV['SSHA_CMD_LOG']
                    this_pid = $$
                    pstart = File.read("/proc/#{$$}/stat").split[21].to_i rescue (p; exit(0))
                    fork do
                        prev_sc = nil
                        logF = File.open "#{info_d_each}/syscall_log", "a"
                        ausycallExist = File.exist? "/usr/bin/ausycall"
                        sc_time = nil
                        slist = {}
                        loop do
                            sc = IO.read "/proc/#{this_pid}/syscall" rescue (p; exit(0))
                            if pstart != (File.read("/proc/#{this_pid}/stat").split[21].to_i rescue (p; exit(0)))
                                exit 0
                            end
                            if sc != prev_sc
                                sc_time = Time.now
                                FileUtils.rm_f "#{info_d_each}/stalled"
                                scnum = sc.split[0].to_i
                                slist[scnum] ||= " " + `ausyscall #{scnum}`.chomp
                                scname = slist[scnum]
                                msg = "#{sc_time.strftime("%Y-%m-%d %H:%M:%S.%L")} ssh[#{this_pid}]#{scname} #{sc}"
                                logF.puts msg
                                logF.flush
                            else
                                if !File.exist? "#{info_d_each}/stalled"
                                    FileUtils.touch "#{info_d_each}/stalled" 
                                    File.utime(sc_time, sc_time, "#{info_d_each}/stalled")
                                end
                            end
                            prev_sc = sc
                            sleep 0.1
                        end
                    end
                end
            end
            if dest && File.exist?("#{ENV['HOME']}/.sshu/hosts/#{dest}")
                exec "ssh", *sshc, "ssha2", "--server", user, *cmdarr
            else
                if cmdarr.empty?
                    if IN_WSL
                        vport = VSC_WSL_PORT
                        r, w = IO.pipe
                        pid = fork do
                            require 'socket'
                            r.close
                            server = TCPServer.new(VSC_WSL_PORT) rescue exit(1)
                            puts "VSCode Control Server listening on port #{VSC_WSL_PORT}"
                            Process.daemon
                            w.puts "started"
                            w.flush
                            w.close

                            loop do
                                # クライアントからの接続を待つ
                                client = server.accept
                                
                                # 各クライアントを別スレッドで処理
                                Thread.new(client) do |conn|
                                    begin
                                        puts "Client connected: #{conn.peeraddr[3]}"
                                        
                                        # データを受信
                                        while line = conn.gets
                                            puts "Received: #{line.chomp}"
                                            line.chomp!
                                            case line
                                            when /^test$/
                                                conn.puts "OK"
                                            when /^open remote\s+([\w\-]+)$/
                                                # エコーバック
                                                host = $1
                                                conn.puts "Echo: #{line}"
                                                system "code --remote ssh-remote+#{host} &"
                                            end
                                        end
                                    rescue => e
                                        puts "Error: #{e.message}"
                                    ensure
                                        conn.close
                                        puts "Client disconnected"
                                    end
                                end
                            end
                        end
                        w.close
                        Process.wait pid
                        ret = r.readpartial(1024) rescue nil
                        if ret
                            if ret.chomp == "started"
                                r.close
                            else
                                STDERR.puts "ERROR: detected abnormal debug monitor."
                                exit 1
                            end
                        end
                    else
                        vport = 0
                        # vport = ENV['VS_CONTROL_PORT']:if.to_i
                        if ENV['VS_CONTROL_PORT']
                            vport = ENV['VS_CONTROL_PORT'].to_i
                        elsif File.exist? "/tmp/vscode_control"
                            ent = Dir.entries("/tmp/vscode_control/sshds").delete_if{ |e| e == "." || e == ".." || e != SYS_START }[0]
                            entst = {}
                            Dir.entries("/tmp/vscode_control/sshds/#{ent}").each do |ent|
                                next if ent !~ /^\d+\.\d+$/
                                sproc_start, spid = ent.split(".")
                                entf = "/tmp/vscode_control/sshds/#{SYS_START}/#{ent}"
                                t = IO.read("/proc/#{spid}/stat").split[21].to_i rescue 0
                                if t == sproc_start.to_i
                                    #FileUtils.rm_f entf rescue nil
                                    entst[entf] = t
                                end
                            end
                            if !entst.empty?
                                vport = catch :found do
                                    entst.keys.sort_by{ |entf| entst[entf] }.reverse_each do |entf|
                                        v = IO.read entf rescue 0
                                        require 'socket'
                                        TCPSocket.open("127.0.0.1", v.to_i) do |s|
                                            s.write "test\n"
                                            resp = s.gets.chomp rescue nil
                                            if resp == "OK"
                                                throw :found, v.to_i
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    free_port = "0"
                    if KEY_CHECK_IN_ADVANCE
                        rand_id = (10**9 + rand(9*10**9)).to_s
                        io = IO.popen [*SSH_ORG, "-q", *sshc, "bash"], "w+"
                        begin
                            io.write('
                                find_free_port() {
                                    local port=$((10000 + RANDOM % 55535))
                                    while (echo >/dev/tcp/127.0.0.1/$port) 2>/dev/null; do
                                        port=$((10000 + RANDOM % 55535))
                                    done
                                    echo $port
                                }

                                FREE_PORT=$(find_free_port)
                                echo $FREE_PORT
                                mkdir -p /tmp/vscode_control/shell_wrappers
                                cat <<END > /tmp/vscode_control/shell_wrappers/'"#{rand_id}"'.ssha_set_vsc_port.sh
        #!/bin/bash

        find_sshd_parent() {
        local pid=\$\$
        
        while [ \$pid -gt 1 ]; do
            # プロセス名を取得
            local proc_name=\$(cat /proc/\$pid/comm 2>/dev/null)
            
            # sshdかチェック
            if [[ "\$proc_name" == "sshd" ]]; then
            echo \$pid
            return 0
            fi
            
            # 親プロセスIDを取得
            pid=\$(awk '"'"'{print \$4}'"'"' /proc/\$pid/stat 2>/dev/null)
            
            if [ -z "\$pid" ]; then
            return 1
            fi
        done
        
        return 1
        }


        export VSCODE_CONTROL_PORT=$FREE_PORT
        SSHD_PID=\$(find_sshd_parent)
        if [ -n "\$SSHD_PID" ]; then
            INFO_DIR=/tmp/vscode_control/sshds/\$(awk '"'"'/btime/ {print \$2}'"'"' /proc/stat)
            mkdir -p \$INFO_DIR
            echo $FREE_PORT > \$INFO_DIR/\$(cat /proc/\$SSHD_PID/stat | awk '"'"'{print \$22}'"'"').\$SSHD_PID
        fi

        exec $(getent passwd $USER | cut -d: -f7)            
        END
                                chmod +x /tmp/vscode_control/shell_wrappers/'"#{rand_id}"'.ssha_set_vsc_port.sh
                            ')
                            io.close_write
                        ensure
                            free_port = io.read.chomp
                            io.close
                        end
                    end
                    if vport != 0
                        if print_tmp_script_file_name
                            proxyBat = "#{WTMPDL}/ssh_proxy.bat"
                            IO.write proxyBat, <<~END
                                @echo off
                                set SSH_ASKPASS=c:\\Program Files\\Git\\mingw64\\bin\\git-askpass.exe
                                set SSH_ASKPASS_REQUIRE=force
                                ssh.exe -F "#{WTMPDW}\\config" -oAddKeysToAgent=yes #{dest}
                            END
                            puts `wslpath -w #{proxyBat}`.chomp
                            STDOUT.flush
                        else
                            do_ssh "ssh", "-R#{free_port}:127.0.0.1:#{vport}", "-oExitOnForwardFailure=yes", "-oAddKeysToAgent=yes", *ARGV, "-t", "/tmp/vscode_control/shell_wrappers/#{rand_id}.ssha_set_vsc_port.sh"
                        end
                    else
                        STDERR.puts "ERROR: cannot find VSCode Control Server port."
                        exit 1
                    end
                else
                    # cmdarrの前に標準出力に乱数を書き出すコマンドを追加、ローカルでこの乱数を検出することで、接続の成功を確認してconfigに登録する
                    case SSH_ORG
                    when "ssh"
                        cmdline = [SSH_ORG, *ARGV]
                        if print_tmp_script_file_name && BY_SSH_BAT
                            proxyScript = "#{WTMPDL}/ssh_proxy.sh"
                            IO.write proxyScript, <<~END
                                #!/bin/bash
                                #{cmdline.shelljoin}    
                            END
                            puts proxyScript
                            STDOUT.flush
                        else
                            exec SSH_ORG, "-oAddKeysToAgent=yes", *ARGV
                        end
                    when "ssh.exe"
                        proxyBat = "#{WTMPDL}/ssh_proxy.bat"
                        begin
                            IO.write proxyBat, <<~END
                                @echo off
                                set SSH_ASKPASS=c:\\Program Files\\Git\\mingw64\\bin\\git-askpass.exe
                                set SSH_ASKPASS_REQUIRE=force
                                ssh.exe -F "#{WTMPDW}\\config" -oAddKeysToAgent=yes #{dest} #{cmdarr.map{ |e| e.include?(" ") ? "\"#{e}\"" : e }.join(" ")}
                            END
                            if print_tmp_script_file_name
                                puts `wslpath -w #{proxyBat}`.chomp
                                STDOUT.flush
                            else
                                exec "/mnt/c/Program Files/Git/usr/bin/winpty.exe", "-Xallow-non-tty", `wslpath -w #{proxyBat}`.chomp
                            end
                        ensure
                            #FileUtils.rm_f proxyBat
                        end
                    end
                end
            end
        end
    end
    return
end


main

